<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Enterprise.ApplicationServices.Core</name>
    </assembly>
    <members>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.CommandHandlerBase`1.HandleAsync(Enterprise.ApplicationServices.Core.Commands.Model.IBaseCommand,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.CommandHandlerBase`1.HandleAsync(`0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.CommandHandlerBase`2.Enterprise#ApplicationServices#Core#Commands#Handlers#IHandleCommand{TCommand}#HandleAsync(`0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.CommandHandlerBase`2.HandleAsync(Enterprise.ApplicationServices.Core.Commands.Model.IBaseCommand,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.CommandHandlerBase`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand">
            <summary>
            Handles commands.
            </summary>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand.HandleAsync(Enterprise.ApplicationServices.Core.Commands.Model.IBaseCommand,System.Threading.CancellationToken)">
            <summary>
            Handle the command.
            </summary>
            <param name="command"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand`1">
            <summary>
            Handles commands of a specific type.
            </summary>
            <typeparam name="TCommand"></typeparam>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand`1.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handle the command.
            </summary>
            <param name="command"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand`2">
            <summary>
            Handles commands of a specific type and returns an explicit result type.
            According to Bertrand Meyer, commands (in CQS) return void (there is no return value).
            Typically, the client of the command handler needs to know if the operation succeeded or failed.
            This is a pragmatic interface that allows a return value.
            Use of this interface is acceptable; however, <see cref="T:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand`1"/> is preferred.
            </summary>
            <typeparam name="TCommand"></typeparam>
            <typeparam name="TResponse"></typeparam>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.IHandleCommand`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handle the command.
            </summary>
            <param name="command"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Handlers.Resolution.IResolveCommandHandler">
            <summary>
            Resolves command handler implementations that can handle specific commands.
            </summary>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.Resolution.IResolveCommandHandler.GetHandlerFor``1(``0)">
            <summary>
            Get the handler implementation that can handle the given command.
            </summary>
            <typeparam name="TCommand"></typeparam>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Commands.Handlers.Resolution.IResolveCommandHandler.GetHandlerFor``2(``0)">
            <summary>
            Get the handler implementation that can handle the given command.
            </summary>
            <typeparam name="TCommand"></typeparam>
            <typeparam name="TResponse"></typeparam>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Model.ICommand">
            <summary>
            This is a marker interface that signifies that an implementing class is a command object.
            It is used primarily for constraint purposes.
            </summary>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Commands.Model.ICommand`1">
            <summary>
            This is a marker interface that signifies that an implementing class is a command object.
            It is used primarily for constraint purposes.
            According to Bertrand Meyer, commands don't have a return value. They return void.
            This interface is a pragmatic compromise that allows for defining a result associated with the command.
            Use of this interface is acceptable; however, <see cref="T:Enterprise.ApplicationServices.Core.Commands.Model.ICommand"/> is preferred.
            </summary>
            <typeparam name="TResponse"></typeparam>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.IHandleQuery`1.HandleAsync(Enterprise.ApplicationServices.Core.Queries.Model.IBaseQuery,System.Threading.CancellationToken)">
            <summary>
            Handle the query and return the typed result.
            </summary>
            <param name="query"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Handlers.IHandleQuery`2">
            <summary>
            Handles queries.
            </summary>
            <typeparam name="TQuery">The explicit type of query that can be handled.</typeparam>
            <typeparam name="TResponse">The expected result type.</typeparam>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.IHandleQuery`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handle a specific type of query and return the typed result.
            </summary>
            <param name="query"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Handlers.IQueryLogic`2">
            <summary>
            Implementations perform the query execution and mapping logic (if required).
            This is used to externalize the actual query implementation to an infrastructure layer.
            This reduces the number of components that need to be created while retaining clean architecture.
            When partnered with prebuilt base query handlers and DI factory methods, this becomes more streamlined.
            </summary>
            <typeparam name="TQuery"></typeparam>
            <typeparam name="TResponse"></typeparam>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.IQueryLogic`2.ExecuteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Execute the query logic.
            </summary>
            <param name="query"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.QueryHandlerBase`2.HandleAsync(Enterprise.ApplicationServices.Core.Queries.Model.IBaseQuery,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.QueryHandlerBase`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Handlers.Resolution.IResolveQueryHandler">
            <summary>
            Resolves query handler implementations that can handle specific queries.
            </summary>
        </member>
        <member name="M:Enterprise.ApplicationServices.Core.Queries.Handlers.Resolution.IResolveQueryHandler.GetQueryHandler``2(``0)">
            <summary>
            Get the handler implementation that can handle the given query.
            </summary>
            <typeparam name="TQuery"></typeparam>
            <typeparam name="TResponse"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Model.IBaseQuery">
            <summary>
            This is a base marker interface.
            It's intended to be used as a single top level reference for generic query constraints.
            </summary>
        </member>
        <member name="P:Enterprise.ApplicationServices.Core.Queries.Model.ICachedQuery.CacheKey">
            <summary>
            The unique cache identifier associated with the query.
            </summary>
        </member>
        <member name="P:Enterprise.ApplicationServices.Core.Queries.Model.ICachedQuery.Expiration">
            <summary>
            The total time to live duration.
            </summary>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Model.IQuery">
            <summary>
            This is a marker interface that signifies that an implementing class is a query object.
            It is used primarily for constraint purposes.
            </summary>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.Queries.Model.IQuery`1">
            <summary>
            This is a marker interface that signifies that an implementing class is a query object.
            It is used primarily for constraint purposes.
            This interface allows for defining an explicit return type that is associated with the query.
            </summary>
            <typeparam name="TResponse"></typeparam>
        </member>
        <member name="T:Enterprise.ApplicationServices.Core.UseCases.IUseCase">
            <summary>
            This is a marker interface for application service objects.
            Each use case is represented as a command or a query.
            </summary>
        </member>
    </members>
</doc>
